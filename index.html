  <!doctype html>
  <html lang="it">
  <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>One Piece ‚Äî Squadre</title>
  <style>
  :root { 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
    --primary: #4f74ff;
    --secondary: #2b356f;
    --highlight: #ffdd57;
    --bg-card: #1a2040;
    --bg-body: #0b1020;
    --pill-cap: #ff4f4f89;
    --pill-vice: #4f95ff93;
    --pill-fighter: #4fff7e7c;
    --glow-bounty: rgba(255,215,0,0.6);
    --glow-devil: rgba(255,0,255,0.6);
    --glow-both: rgba(0, 255, 255, 0.685);
    --glow-conqueror: rgba(255,0,0,0.6);
  }

/* --- Page Background --- */
body {
  margin: 0;
  font-family: 'Pirata One', sans-serif;
  background: 
    url('images/parchment-texture.jpg') center/cover no-repeat fixed, /* old paper */
    linear-gradient(180deg, #f4fcff 0%, #1e3f66 100%); /* sky to ocean gradient */
  background-blend-mode: multiply;
  color: #3b2f1a;
}

/* Optional: add a subtle overlay of a map */
body::before {
  content: "";
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: url('images/one-piece-map.png') center/contain repeat;
  opacity: 0.15;
  z-index: -1;
  pointer-events: none;
}

/* Scrollbar Styling (optional) */
::-webkit-scrollbar {
  width: 10px;
}
::-webkit-scrollbar-track {
  background: rgba(245, 222, 179, 0.5);
}
::-webkit-scrollbar-thumb {
  background: #b88b57;
  border-radius: 5px;
}
::-webkit-scrollbar-thumb:hover {
  background: #a0713d;
}
  .attributes {
    background: rgba(255, 224, 186, 0.18);
    border: 2px solid #c49a6c;
    border-radius: 12px;
    padding: 10px;
    margin-top: 8px;
    box-shadow: inset 0 0 10px rgba(0,0,0,0.15);
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    justify-content: center;
  }

.attributes .pill, .grid .pill {
  font-family: 'Treasure Map Deadhand', cursive;
  font-weight: bold;
  background: linear-gradient(to bottom, #fef3c2, #f2d7b4);
  border: 2px solid #b88b57;
  color: #5a3e1b;
  box-shadow: 0 2px 4px rgba(0,0,0,0.25);
}

  .attributes .pill:hover {
    transform: scale(1.05);
    background: linear-gradient(to bottom, #fff7e6, #f5d9b0);
  }

  .aliases {
    margin-top: 8px;
    font-style: italic;
    font-size: 12px;
    opacity: 0.85;
    text-align: center;
  }


  .card-container { 
    display: flex; 
    gap: 20px; 
    flex-wrap: wrap; 
    justify-content: center; 
    margin-bottom: 20px; 
  }

.card {
  position: relative;
  overflow: visible;
  width: min(320px, 92vw);
  background: linear-gradient(145deg, #f4e0c3, #d9b98b); /* aged paper gradient */
  border-radius: 20px;
  box-shadow: 0 10px 30px rgba(0,0,0,.6);
  cursor: pointer;
  transition: transform 0.3s, box-shadow 0.3s, filter 0.3s;
  font-family: 'Times New Roman', cursive; /* pirate style font */
  color: #3b2f1a;
  border: 2px solid #b88b57;
}
  .card:hover { 
    transform: translateY(-8px) scale(1.02); 
    box-shadow: 0 20px 50px rgba(0,0,0,.8); 
    filter: brightness(1.05);
  }
  .card h1 {
  margin: 8px 0;
  font-size: 28px;            /* üëà pi√π grande */
  font-weight: 400;           /* üëà molto pi√π marcato */
  text-align: center;
  color: #3b0202;             /* üëà colore pi√π brillante */
  font-family: 'Times New Roman', cursive; /* mantiene il look piratesco */
  letter-spacing: 1px;
  text-transform: uppercase;  /* üëà tutto maiuscolo per pi√π impatto */
  transition: transform 0.2s ease, text-shadow 0.2s ease;
}

.card:hover h1 {
  transform: scale(1.08);     /* üëà leggero ingrandimento al passaggio */
  text-shadow: 
    0 0 12px rgba(255, 221, 87, 1), 
    0 0 22px rgba(255, 140, 0, 0.9),
    3px 3px 2px #000;
}

  /* Conqueror's Haki Lightning Aura */

/* Conqueror's Haki Lightning Aura - always visible */
.card-conqueror {
  position: relative; 
  overflow: visible;
  box-shadow: 0 0 35px 12px var(--glow-conqueror); /* stronger by default */
  transition: transform 0.3s, box-shadow 0.3s, filter 0.3s;
}
.card-conqueror::before {
  content: "";
  position: absolute;
  top: -30px;
  left: -30px;
  right: -30px;
  bottom: -30px;
  background: url('images/light.png') repeat;
  background-size: contain;
  z-index: -1;
  pointer-events: none;
  filter: brightness(1.5) blur(2px);
  opacity: 0.8;
  animation: flashAura 1s infinite;
}

@keyframes flashAura {
  0%   { opacity: 0.7; }
  10%  { opacity: 1; }
  20%  { opacity: 0.4; }
  30%  { opacity: 0.8; }
  40%  { opacity: 0.5; }
  50%  { opacity: 1; }
  60%  { opacity: 0.3; }
  70%  { opacity: 0.9; }
  80%  { opacity: 0.6; }
  90%  { opacity: 1; }
  100% { opacity: 0.7; }
}



/* Hover just makes it stronger and moves the card */
.card-conqueror:hover {
  transform: translateY(-8px) scale(1.02);
  box-shadow: 0 0 35px 12px var(--glow-conqueror), 0 20px 50px rgba(0,0,0,.8);
  filter: brightness(1.05);
}



/* Hero Image */
.hero {
  width: 100%; /* fill card width */
  height: auto;
  max-height: 380px; /* increased from your current value */
  object-fit: contain; /* keeps proportions without cropping */
  display: block;
  margin: 0 auto;
  border: 4px solid #8B4513; /* pirate poster frame look */
  border-radius: 10px;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
}


 .content {
  padding: 20px 22px 24px;
  background: rgba(255, 248, 220, 0.85); /* slightly transparent parchment look */
  border-radius: 0 0 20px 20px;
  box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
  border-top: 2px solid #b88b57;
}

h1 {
  margin: 0 0 6px;
  font-size: 26px;
  color: #b84100; /* bold pirate red */
  text-shadow: 2px 2px 0 #fef3c2, 0 0 6px rgba(0,0,0,.5);
}

.meta {
  opacity: 0.9;
  font-size: 14px;
  font-style: italic;
  color: #4b3621;
  text-shadow: 1px 1px 0 #fff3c2;
  margin-bottom: 10px;
  text-align: center;
}

  .grid { 
    display: grid; 
    grid-template-columns: 1fr 1fr; 
    gap: 12px; 
    margin: 12px 0; 
  }

  .pill { 
     background: linear-gradient(to bottom, #243061, #1d274e);
     color: #f6f7ff;
  box-shadow: 0 2px 4px rgba(0,0,0,.35);
    padding: 8px 10px; 
    border-radius: 999px; 
    text-align: center; 
    font-size: 13px; 
    transition: background 0.2s; 
  }
  .pill:hover { 
    background: var(--primary); 
  }

  .actions { 
    display: flex; 
    gap: 12px; 
    margin-bottom: 12px; 
    flex-wrap: wrap; 
    justify-content: center; 
    
  }
  button { 
    cursor: pointer; 
    border: 0; 
    border-radius: 999px; 
    padding: 12px 20px; 
    font-weight: 700; 
    background: var(--primary); 
    color: white; 
    transition: background 0.2s, transform 0.2s; 
  }
  button:hover { 
    background: #627fff; 
    transform: scale(1.05);
  }
  button.secondary { 
    background: var(--secondary); 
  }

  #counter { 
    margin-top: 8px; 
    font-size: 14px; 
    opacity: .9; 
    text-align: center; 
    color: var(--highlight);
  }

  .footer { 
    opacity: .6; 
    font-size: 12px; 
    text-align: center; 
    padding: 10px 0 18px; 
  }

  .teams { 
    display: flex; 
    gap: 40px; 
    margin-top: 20px; 
    flex-wrap: wrap; 
    justify-content: center; 
  }

  .team { 
    background: linear-gradient(145deg, #013c53, #013c53); 
    padding: 16px; 
    border-radius: 20px; 
    width: 320px; 
    box-shadow: 0 10px 30px rgba(245, 237, 237, 0.5); 
    transition: transform 0.2s; 
  }
  .team:hover { 
    transform: translateY(-5px); 
  }
  .team h2 { 
    margin-top: 0; 
    text-align: center; 
    color: var(--highlight); 
    font-weight: 700; 
    font-size: 20px;
    text-shadow: 0 2px 4px rgba(137, 94, 255, 0.6);
  }

  .role { 
    margin: 8px 0; 
    background-color: #4f74ff;
    padding: 10px 12px; 
    gap: 8px;
    border-radius: 12px; 
    font-size: 14px; 
    cursor: pointer; 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    
  }
  .role.capitano { background: var(--pill-cap); color: rgb(245, 232, 255); }
  .role.vice { background: var(--pill-vice); color: rgb(246, 209, 255); }
  .role.combattente { background: var(--pill-fighter); color: #ffc7ff; }
  .role:hover { 
    opacity: 0.5; 
    transform: scale(1.02);
  }
  .selected { 
    outline: 3px solid var(--highlight); 
  }

  .role-menu { 
    position: absolute; 
    background: #e8dcfd; /* solid background */
    border: 1px solid var(--primary); 
    border-radius: 12px; 
    padding: 8px; 
    display: none; 
    z-index: 10; 
    box-shadow: 0 8px 20px rgba(255, 32, 225, 0.7);
    transition: opacity 0.5s ease;
}

  .role-menu div { 
    padding: 8px 12px; 
    cursor: pointer; 
    border-radius: 8px; 
  }
  .role-menu div:hover { 
    background: var(--primary); 
    color: rgb(172, 171, 248); 
  }


/* highlight drop target */
.role.drop-target {
  outline: 2px dashed rgba(255,221,87,0.9);
  transform: translateX(6px);
  background: linear-gradient(90deg, rgba(255,221,87,0.06), rgba(255,221,87,0.02));
}

/* placeholder style if you use one */
.role.placeholder {
  background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(0,0,0,0.03));
  border: 2px dashed rgba(255,255,255,0.06);
  min-height: 44px;
}

/* small responsive touch improvement */
@media (pointer: coarse) {
  .drag-handle { display: none; } /* on touch devices, whole row draggable is fine */
}

.legend {
  display: flex;
  flex-wrap: wrap;
  gap: 14px;
  justify-content: center;
  align-items: center;
  font-family: 'One Piece', sans-serif;
  font-size: 14px;
  background: rgba(88, 48, 182, 0.6);
  padding: 10px 15px;
  border: 3px solid #d4a373;
  border-radius: 12px;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
  color: #ffd66b; /* üåü colore testo leggibile */
  text-shadow: 1px 1px 2px #000; /* pi√π contrasto */
}

.legend h3 {
  margin: 0 100% 8px 0;
  font-size: 16px;
  text-decoration: underline;
  color: #ffeb9c; /* leggermente pi√π chiaro per il titolo */
  text-shadow: 2px 2px 3px #000;
}

.legend-box {
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 4px;
  margin-right: 6px;
  box-shadow: 0 0 6px rgba(255,255,255,0.4);
}

.glow-bounty { background: gold; box-shadow: 0 0 10px gold; }
.glow-devil { background: violet; box-shadow: 0 0 10px violet; }
.glow-both { background: rgba(0, 255, 255, 0.685); box-shadow: 0 0 10px gold; }
.glow-conqueror { background: red; box-shadow: 0 0 10px red; }
.glow-lightning { 
  background: url('images/light.png') center/cover no-repeat; 
  border: 1px solid rgba(255,255,255,0.5);
}
/* highlight team corrente */
.team.active {
  box-shadow: 0 12px 30px rgba(255, 221, 87, 0.18);
  transform: translateY(-4px);
  border: 2px solid #ffd66b;
}

/* card gi√† assegnata: aspetto e blocco interazioni */
.card.assigned {
  opacity: 0.45;
  filter: grayscale(70%) saturate(.6);
  pointer-events: none;
  transform: none;
}
/* highlight per selezione swap */
.role.selected-for-swap {
  outline: 3px dashed #ffdd57;
  transform: scale(1.02);
  box-shadow: 0 8px 18px rgba(255,221,87,0.12);
}

/* Overlay scuro dietro la modal */
#swapOverlay {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.65);
  z-index: 10001;
  display: none;
}

/* Modal migliorata */
#swapModal {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%) scale(0.9);
  min-width: 340px;
  max-width: 95vw;
  background: rgba(30, 28, 48, 0.9);
  backdrop-filter: blur(8px);
  border: 2px solid #ffcc33;
  color: #fff;
  padding: 20px;
  border-radius: 18px;
  z-index: 10002;
  box-shadow: 0 16px 48px rgba(0,0,0,0.8);
  display: none;
  opacity: 0;
  transition: all 0.3s ease;
}

#swapModal.show {
  display: block;
  opacity: 1;
  transform: translate(-50%,-50%) scale(1);
}

#swapModal h3 {
  margin:0 0 12px 0;
  font-size:20px;
  text-align:center;
  color: #ffcc33;
  text-shadow: 0 2px 6px rgba(0,0,0,0.6);
}

#swapModal p {
  margin:0 0 14px 0;
  opacity:.9;
  text-align:center;
}

/* Bottoni pi√π belli */
#swapModal .swap-actions {
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  justify-content:center;
  margin-bottom:10px;
}

#swapModal button {
  padding:10px 14px;
  border-radius:10px;
  border:0;
  cursor:pointer;
  font-weight:700;
  display:flex;
  align-items:center;
  gap:6px;
  transition: all 0.2s ease;
}

#swapModal button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.3);
}

/* Colori diversi per azioni */
#swapBtn1, #swapBtn2 {
  background: linear-gradient(180deg,#ffcc33,#d9a600);
  color:#111;
}

#swapDone {
  background: linear-gradient(180deg,#4caf50,#388e3c);
  color:#fff;
}

#swapCancel {
  background: linear-gradient(180deg,#e53935,#b71c1c);
  color:#fff;
}


/* ===== VS Banner ===== */
#vsBanner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.6);
  opacity: 0;
  font-family: 'Treasure Map Deadhand', cursive;
   font-size: clamp(36px, 8vw, 100px);
  font-weight: 900;
  letter-spacing: 6px;
  color: #ffdd57;
  padding: 12px 24px;
  border: 4px solid #d4a373;
  border-radius: 24px;
  background: radial-gradient(ellipse at center, rgba(0,0,0,0.75), rgba(0,0,0,0.35) 60%, rgba(0,0,0,0) 90%);
  text-shadow: 0 0 20px red, 0 0 40px #ff0000, 0 0 60px #ff6600;
  box-shadow: 0 0 40px rgba(255, 102, 0, 0.8), inset 0 0 20px rgba(255, 221, 87, 0.4);
  transition: transform 0.6s ease, opacity 0.6s ease;
  z-index: 9999;
  pointer-events: none;
}

#vsBanner.show {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
  animation: pulseVS 1s infinite alternate, shakeVS 0.6s ease-in-out 1;
}

@keyframes pulseVS {
  from { text-shadow: 0 0 20px red, 0 0 40px #ff0000; }
  to   { text-shadow: 0 0 40px yellow, 0 0 80px orange; }
}

@keyframes shakeVS {
  0%   { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
  25%  { transform: translate(calc(-50% + 6px), calc(-50% - 4px)) scale(1.02) rotate(-1deg); }
  50%  { transform: translate(calc(-50% - 5px), calc(-50% + 5px)) scale(1.02) rotate(1deg); }
  75%  { transform: translate(calc(-50% + 4px), calc(-50% + 2px)) scale(1.01) rotate(-0.5deg); }
  100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
}
/* ===== Arena Mode ===== */

#arenaOverlay {
  display: none; /* toggled by JS */
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  flex-direction: column;
  justify-content: center; /* center vertically */
  align-items: center;
  gap: 24px;
  padding: 24px;
  width: min(960px, 90vw);
  max-height: 90vh;
  overflow-y: auto;
  background: linear-gradient(135deg, #1f1f2e, #2c2c44);
  border: 3px solid #ffdd57;
  border-radius: 20px;
  box-shadow: 0 0 40px rgba(255, 221, 87, 0.5), inset 0 0 20px rgba(255, 215, 0, 0.2);
  color: #fff;
  font-family: 'Times New Roman', cursive;
  z-index: 10000;
  text-align: center;
  transition: transform 0.4s ease, opacity 0.4s ease;
  
}



#arenaTop{
  width:min(960px, 95vw);
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-family:'Times New Roman', cursive;
  font-weight:700;
  letter-spacing:1px;
  text-shadow:0 0 8px #000;
    flex-direction: column;
  gap: 8px;
  text-align: center;;
}
@media(min-width: 600px) {
  #arenaTop {
    flex-direction: row;
    justify-content: space-between;
    text-align: left;
  }
}

#arenaDuelCounter{ font-size:18px; opacity:.9; }
#arenaScore{ font-size:20px; }
/* === Particelle === */
#particleContainer {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  overflow: hidden;
  z-index: 9998; /* sotto al VS banner */
}

.particle {
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: gold;
  opacity: 0.8;
  animation: particleFall 2s linear forwards;
  box-shadow: 0 0 8px gold;
}

@keyframes particleFall {
  0%   { transform: translateY(0) scale(1); opacity: 1; }
  100% { transform: translateY(120vh) scale(0.3); opacity: 0; }
}

/* === Fumo === */
.smoke {
  position: absolute;
  width: 40px;
  height: 40px;
  background: radial-gradient(circle, rgba(200,200,200,0.5) 0%, rgba(80,80,80,0) 70%);
  border-radius: 50%;
  animation: smokeRise 3s ease-out forwards;
  opacity: 0.6;
}

@keyframes smokeRise {
  0%   { transform: translateY(0) scale(0.5); opacity: 0.6; }
  50%  { opacity: 0.4; }
  100% { transform: translateY(-200px) scale(1.8); opacity: 0; }
}


#duelWrapper{
  width:min(960px, 95vw);
  background:rgba(20,20,20,.7);
  border:3px solid #d4a373;
  border-radius:20px;
  padding:24px;
  box-shadow:0 0 24px rgba(0,0,0,.4), inset 0 0 12px rgba(0,0,0,.4);
}

.duel-container {
  display: flex;
  align-items: center;
  justify-content: center;   /* üëà aggiunto */
  gap: 48px;
  text-align: center;
  flex-wrap: wrap; /* se serve su schermi piccoli */
}

@media(min-width: 600px) {
  .duel-container {
    flex-direction: row;
    gap: 48px;
  }
}

.duel-side {
  display: flex;
  flex-direction: column;  /* immagine sopra, nome sotto */
  align-items: center;     /* üëà centrato */
  justify-content: center;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  border-radius: 16px;
  background: linear-gradient(145deg, #3b3b5c, #202040);
  padding: 12px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.5);
}

.duel-side img {
  display: block;
  margin: 0 auto;
  max-width: 240px;   /* leggermente pi√π grande */
  height: auto;
  border-radius: 12px;
  border: 2px solid #ffdd57;
}

.duel-side:hover {
  transform: scale(1.08);
  box-shadow: 0 0 28px rgba(255, 221, 87, 0.8);
  filter: brightness(1.1);
}

.duel-role {
  font-family: 'Poppins', sans-serif;
  font-size: 36px;   /* üëà pi√π grande */
  font-weight: 900;
  color: #ffdd57;
  text-transform: uppercase;
  letter-spacing: 3px;
  text-shadow: 0 0 8px #000, 0 0 16px #ffbb00;
  margin: 0 20px;
  text-align: center;   /* üëà centrato */
  flex: 0 0 100%;       /* prende una riga intera al centro */
}

.duel-side img:hover{
  transform:scale(1.06);
  box-shadow:0 0 22px rgba(255,215,0,.8);
  filter:brightness(1.05);
}

.char-name{
  margin-top:8px;
  font-weight:800;
  font-size:18px;
  text-shadow:0 0 6px #000;
}

.arena-btn {
  cursor: pointer;
  border: 0;
  border-radius: 12px;
  padding: 14px 24px;
  font-weight: 800;
  background: linear-gradient(135deg, #ffcc33, #ffaa00);
  color: #1b1b2f;
  font-size: 16px;
  box-shadow: 0 6px 16px rgba(255, 170, 0, 0.6);
  transition: all 0.2s;
}

.arena-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 0 24px rgba(255, 221, 87, 0.9);
  filter: brightness(1.15);
}


#arenaBottom{ margin-top:8px; 
width: 100%; /* full width on small screens */
  max-width: 300px;
}
.role-ghost { opacity: 0.6; transform: scale(.99); }
.drag-handle { cursor: grab; margin-right:8px; user-select:none; }
@media (pointer: coarse) { .drag-handle { display:none; } } /* su touch nasconde handle */



  </style>
  </head>
  <body>

  <div class="actions">
    <button id="randomBtn">üé≤ Random</button>
    <button id="noRepeatBtn" class="secondary">üîÅ No ripetizioni</button>
      <button id="resetBtn" class="secondary">‚ôªÔ∏è Reset</button>
  </div>
  <div id="counter">0 / 0</div>
  <div class="card-container" id="cards"></div>
<div class="teams">
<div class="team" id="team1" role="list" aria-label="Giocatore 1">
  <h2>Giocatore 1</h2>
  <div class="roles-list">
    <div class="role capitano" data-role="Capitano" role="listitem" tabindex="0">Capitano: ‚Äî</div>
    <div class="role vice"    data-role="Vice Capitano" role="listitem" tabindex="0">Vice Capitano: ‚Äî</div>
    <div class="role combattente" data-role="Primo Combattente" role="listitem" tabindex="0">Primo Combattente: ‚Äî</div>
    <div class="role combattente" data-role="Secondo Combattente" role="listitem" tabindex="0">Secondo Combattente: ‚Äî</div>
    <div class="role combattente" data-role="Terzo Combattente" role="listitem" tabindex="0">Terzo Combattente: ‚Äî</div>
  </div>
</div>
    <div class="team" id="team2" role="list" aria-label="Giocatore 2">
  <h2>Giocatore 2</h2>
  <div class="roles-list">
    <div class="role capitano" data-role="Capitano" role="listitem" tabindex="0">Capitano: ‚Äî</div>
    <div class="role vice"    data-role="Vice Capitano" role="listitem" tabindex="0">Vice Capitano: ‚Äî</div>
    <div class="role combattente" data-role="Primo Combattente" role="listitem" tabindex="0">Primo Combattente: ‚Äî</div>
    <div class="role combattente" data-role="Secondo Combattente" role="listitem" tabindex="0">Secondo Combattente: ‚Äî</div>
    <div class="role combattente" data-role="Terzo Combattente" role="listitem" tabindex="0">Terzo Combattente: ‚Äî</div>
  </div>
</div>
</div>
  <div class="role-menu" id="roleMenu"></div>

 <div class="legend">
  <div><span class="legend-box glow-bounty"></span> Bounty > 2.5B</div>
  <div><span class="legend-box glow-devil"></span> Devil Fruit</div>
  <div><span class="legend-box glow-both"></span> Bounty + Devil Fruit</div>
  <div><span class="legend-box glow-conqueror"></span> Conqueror‚Äôs Haki</div>
</div>


  <div class="footer">One Piece fan project ‚Äî solo per uso personale</div>

  <script>
  let data = [];
  let pool = [];
  let totalCharacters = 0;
  let currentPlayer = 1;
  let currentChar = null;

  const $ = (id) => document.getElementById(id);
  const assigned = new Set();

async function load() {
  try {
    const res = await fetch('characters.json');
    if (!res.ok) throw new Error('HTTP ' + res.status);
    data = await res.json();
  } catch (err) {
    console.error('Errore caricamento characters.json', err);
    document.getElementById('cards').innerHTML =
      '<div style="color:#c33;padding:24px;text-align:center;">Errore caricamento characters.json ‚Äî vedi console (F12).</div>';
    return;
  }
  totalCharacters = data.length;
  pool = [...data];

 await showCards([randomFrom(data)]);
restoreTeams();
normalizeRoles();   // aggiungi
initSortable();     // poi inizializza Sortable
updateCurrentPlayerUI();
updateCounter();
}

  function randomFrom(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

// cache per evitare controlli ripetuti
const _webpExistenceCache = {};

// controlla se webp esiste (tramite caricamento immagine, risolve true/false)
function checkWebpExists(webpPath) {
  return new Promise((resolve) => {
    if (_webpExistenceCache.hasOwnProperty(webpPath)) {
      return resolve(_webpExistenceCache[webpPath]);
    }
    const t = new Image();
    t.onload = () => { _webpExistenceCache[webpPath] = true; resolve(true); };
    t.onerror = () => { _webpExistenceCache[webpPath] = false; resolve(false); };
    // inizio richiesta
    t.src = webpPath + (webpPath.includes('?') ? '&' : '?') + 'v=1'; // cache-buster facoltativo
  });
}

// crea elemento immagine responsivo: usa .webp solo se esiste, altrimenti il path originale
async function createResponsiveImage(imgPath, alt = '', cls = '') {
  const webpPath = imgPath.replace(/\.(jpg|jpeg|png)$/i, '.webp');
  const hasWebp = await checkWebpExists(webpPath);

  if (hasWebp) {
    const picture = document.createElement('picture');

    const source = document.createElement('source');
    source.srcset = webpPath;
    source.type = 'image/webp';

    const img = document.createElement('img');
    if (cls) img.className = cls;
    img.src = webpPath;
    img.alt = alt;
    img.loading = 'lazy';

    picture.appendChild(source);
    picture.appendChild(img);
    return picture;
  } else {
    const img = document.createElement('img');
    if (cls) img.className = cls;
    img.src = imgPath;
    img.alt = alt;
    img.loading = 'lazy';
    return img;
  }
}

// showCards ora √® async e crea i nodi DOM ‚Äî incolla al posto della tua versione corrente
async function showCards(chars) {
  const container = $('cards');
  container.innerHTML = "";
  for (const char of chars) {
    const card = document.createElement("div");
    card.className = "card";

    // Glow effects (stesso tuo codice)
    if (char.bounty && parseInt(String(char.bounty).replace(/\D/g,'')) > 2500000000 
        && char.devil_fruit && char.conqueror_haki) {
      card.classList.add("conqueror", "card-conqueror");
    } else if (char.conqueror_haki) {
      card.classList.add("conqueror", "card-conqueror");
    } else if (char.bounty && parseInt(String(char.bounty).replace(/\D/g,'')) > 2500000000 
               && char.devil_fruit) {
      card.style.boxShadow = `0 0 20px 5px var(--glow-both)`;
    } else if (char.bounty && parseInt(String(char.bounty).replace(/\D/g,'')) > 2500000000) {
      card.style.boxShadow = `0 0 20px 5px var(--glow-bounty)`;
    } else if (char.devil_fruit) {
      card.style.boxShadow = `0 0 20px 5px var(--glow-devil)`;
    }

    // crea immagine responsiva (usa webp se esiste)
    const imgEl = await createResponsiveImage(char.image, char.name, 'hero');

    // crea il contenuto testuale (usa innerHTML per semplicit√†)
    const content = document.createElement('div');
    content.className = 'content';
    content.innerHTML = `
      <h1>${char.name}</h1>
      <div class="meta">${char.crew || '‚Äî'}</div>
      <div class="grid">
        <div class="pill">${char.role || '‚Äî'}</div>
        <div class="pill">${char.bounty ? `Bounty: ${char.bounty}` : 'Bounty: ‚Äî'}</div>
      </div>
      <div class="grid">
        <div class="pill">${(char.aliases && char.aliases.length) ? char.aliases.join(', ') : '‚Äî'}</div>
        <div class="pill">Devil fruit: ${char.devil_fruit ?? '‚Äî'}</div>
      </div>
    `;

    card.appendChild(imgEl);
    card.appendChild(content);
    card.dataset.name = char.name;

    card.addEventListener('click', (e) => showRoleMenu(e, char));
    container.appendChild(card);
  }
  markAssignedOnCards();
}

// renderArenaDuel diventa async (viene chiamata senza await ma funziona)
async function renderArenaDuel() {
  const d = arenaState.duels[arenaState.idx];

  // Top bar
  $('arenaDuelCounter').textContent =
    `Duello ${arenaState.idx + 1} / ${arenaState.duels.length}`;
  $('arenaScore').textContent =
    `Giocatore 1 ${arenaState.score1} ‚Äî ${arenaState.score2} Giocatore 2`;

  // svuota e costruisci con DOM
  const wrapper = $('duelWrapper');
  wrapper.innerHTML = ""; // svuota

  const duelContainer = document.createElement('div');
  duelContainer.className = 'duel-container';

  // lato 1
  const pick1 = document.createElement('div');
  pick1.className = 'duel-side';
  pick1.id = 'pick1';
  const img1 = await createResponsiveImage(d.char1.image, d.char1.name);
  const name1 = document.createElement('div');
  name1.className = 'char-name';
  name1.textContent = d.char1.name;
  pick1.appendChild(img1);
  pick1.appendChild(name1);

  // ruolo (al centro)
  const roleDiv = document.createElement('div');
  roleDiv.className = 'duel-role';
  roleDiv.innerHTML = `‚öîÔ∏è ${d.role} ‚öîÔ∏è`;

  // lato 2
  const pick2 = document.createElement('div');
  pick2.className = 'duel-side';
  pick2.id = 'pick2';
  const img2 = await createResponsiveImage(d.char2.image, d.char2.name);
  const name2 = document.createElement('div');
  name2.className = 'char-name';
  name2.textContent = d.char2.name;
  pick2.appendChild(img2);
  pick2.appendChild(name2);

  duelContainer.appendChild(pick1);
  duelContainer.appendChild(roleDiv);
  duelContainer.appendChild(pick2);

  wrapper.appendChild(duelContainer);

  // eventi click
  $('pick1').onclick = () => recordArenaWin(1);
  $('pick2').onclick = () => recordArenaWin(2);
  $('arenaClose').onclick = () => { $('arenaOverlay').style.display = 'none'; };
}


  function updateCounter() {
    const used = totalCharacters - pool.length;
    $('counter').textContent = `${used} / ${totalCharacters}`;
  }

  $('randomBtn').addEventListener('click', () => {
    showCards([randomFrom(data)]);
  });

  $('noRepeatBtn').addEventListener('click', () => {
    if (pool.length === 0) {
      alert("Tutti i personaggi sono stati mostrati! Si ricomincia.");
      pool = [...data];
    }
    const idx = Math.floor(Math.random() * pool.length);
    const pick = pool.splice(idx, 1)[0];
    showCards([pick]);
    updateCounter();
  });

  function showRoleMenu(e, char) {
    currentChar = char;
    const menu = $('roleMenu');
    menu.innerHTML = '';
    const team = currentPlayer === 1 ? 'team1' : 'team2';
    const roles = Array.from($(team).querySelectorAll('.role'));
    roles.forEach(roleDiv => {
      if (roleDiv.textContent.endsWith('‚Äî')) {
        const item = document.createElement('div');
        item.textContent = roleDiv.dataset.role;
        item.addEventListener('click', () => assignCharacterToRole(roleDiv));
        menu.appendChild(item);
      }
    });
    menu.style.display = 'block';
    menu.style.top = e.clientY + 'px';
    menu.style.left = e.clientX + 'px';
  }

  

function assignCharacterToRole(roleDiv) {
  const name = currentChar?.name;
  if (!name) return;

  // se gi√† assegnato, avvisa e non procedere (NON toggle del currentPlayer)
  if (assigned.has(name)) {
    alert('‚ùå Personaggio gi√† assegnato in una squadra.');
    $('roleMenu').style.display = 'none';
    return;
  }

  // assegna: imposta testo e dataset per affidabilit√†
  roleDiv.textContent = `${roleDiv.dataset.role}: ${name}`;
  roleDiv.dataset.character = name;
  assigned.add(name);

  // UI + persistenza + marcatura card
  $('roleMenu').style.display = 'none';
  persistTeams();
  markAssignedOnCards();
  updateCounter();

  // toggle del turno SOLO dopo assegnazione riuscita
  currentPlayer = currentPlayer === 1 ? 2 : 1;
  updateCurrentPlayerUI();
  checkTeamsFull();
}



  document.addEventListener('click', (e) => {
    if (!e.target.closest('.card') && !e.target.closest('#roleMenu')) {
      $('roleMenu').style.display = 'none';
    }
  });
  // ---- VS helpers ----
function isTeamFull(teamId) {
  return Array.from($(teamId).querySelectorAll('.role'))
    .every(r => !r.textContent.trim().endsWith('‚Äî'));
}

function teamsAreFull() {
  return isTeamFull('team1') && isTeamFull('team2');
}

function showVsBanner(text = 'VS') {
  const el = $('vsBanner');
  el.textContent = text;
  el.classList.add('show');
  clearTimeout(showVsBanner._hideTimer);
  showVsBanner._hideTimer = setTimeout(() => {
    el.classList.remove('show');
  }, 3000); // hide after 3s
}


// ===== Arena State =====
let arenaState = {
  duels: [],
  idx: 0,
  score1: 0,
  score2: 0
};

// Build pairs: Captain vs Captain, Vice vs Vice, ...
function buildDuels() {
  const roles1 = $('team1').querySelectorAll('.role');
  const roles2 = $('team2').querySelectorAll('.role');
  const arr = [];

  roles1.forEach((r1, i) => {
    const r2 = roles2[i];
    if (!r1 || !r2) return;

    const name1 = (r1.dataset.character || '').trim();
    const name2 = (r2.dataset.character || '').trim();

    const char1 = data.find(c => c.name === name1);
    const char2 = data.find(c => c.name === name2);

    if (char1 && char2) {
      const roleLabel = r1.dataset.role || (r1.textContent.split(':')[0] || '').trim();
      arr.push({ role: roleLabel, char1, char2 });
    }
  });

  // üëá inverti l‚Äôordine: dal terzo combattente al capitano
  return arr.reverse();
}



function startArenaAfterVS() {
  const duels = buildDuels();
  if (!duels.length) return;

  arenaState = { duels, idx: 0, score1: 0, score2: 0 };
  const overlay = $('arenaOverlay');
  overlay.style.opacity = 0;
  overlay.style.display = 'flex';
  
  renderArenaDuel();

  // Fade in
  setTimeout(() => {
    overlay.style.transition = 'opacity 0.5s';
    overlay.style.opacity = 1;
  }, 50);
}


function recordArenaWin(team) {
  if (team === 1) arenaState.score1++; else arenaState.score2++;

  // Advance
  arenaState.idx++;
  if (arenaState.idx >= arenaState.duels.length) {
    endArenaBattle();
  } else {
    renderArenaDuel();
  }
}

function endArenaBattle() {
  const { score1, score2 } = arenaState;
  let msg = `ü§ù Pareggio (${score1} - ${score2})`;
  if (score1 > score2) msg = `üè¥‚Äç‚ò†Ô∏è Giocatore 1 vince! (${score1} - ${score2})`;
  if (score2 > score1) msg = `üè¥‚Äç‚ò†Ô∏è Giocatore 2 vince! (${score2} - ${score1})`;

  $('arenaDuelCounter').textContent = '';
  $('arenaScore').textContent = '';
  $('duelWrapper').innerHTML = `
    <div style="text-align:center; padding:24px;">
      <h1 style="margin:0 0 12px 0;">${msg}</h1>
      <p style="opacity:.9">La battaglia √® conclusa.</p>
    </div>
  `;
}
// aggiorna UI che evidenzia quale giocatore √® corrente
function updateCurrentPlayerUI() {
  document.querySelectorAll('.team').forEach(t => t.classList.remove('active'));
  const el = document.getElementById('team' + currentPlayer);
  if (el) el.classList.add('active');
}

// segna sulle card quali personaggi sono gi√† assegnati (usa dataset.name impostato in showCards)
function markAssignedOnCards() {
  const cards = document.querySelectorAll('#cards .card');
  cards.forEach(card => {
    const name = card.dataset.name || (card.querySelector('h1')?.textContent?.trim() || '');
    if (name && assigned.has(name)) {
      card.classList.add('assigned');
    } else {
      card.classList.remove('assigned');
    }
  });
}

// conta assegnati e aggiorna il contatore
function updateCounter() {
  const used = assigned.size;
  $('counter').textContent = `${used} / ${totalCharacters}`;
}
function persistTeams() {
  try {
    const state = {
      team1: Array.from(document.querySelectorAll('#team1 .role')).map(r => r.dataset.character || null),
      team2: Array.from(document.querySelectorAll('#team2 .role')).map(r => r.dataset.character || null),
      assigned: [...assigned],
      currentPlayer
    };
    localStorage.setItem('op_teams_v1', JSON.stringify(state));
  } catch (e) {
    console.warn('persistTeams failed', e);
  }
}

function restoreTeams() {
  try {
    const raw = localStorage.getItem('op_teams_v1');
    if (!raw) return;
    const s = JSON.parse(raw);

    const roles1 = document.querySelectorAll('#team1 .role');
    const roles2 = document.querySelectorAll('#team2 .role');

    if (Array.isArray(s.team1)) {
      s.team1.forEach((name, i) => {
        if (!roles1[i]) return;
        roles1[i].dataset.character = name || '';
        roles1[i].textContent = `${roles1[i].dataset.role}: ${name || '‚Äî'}`;
        if (name) assigned.add(name);
      });
    }
    if (Array.isArray(s.team2)) {
      s.team2.forEach((name, i) => {
        if (!roles2[i]) return;
        roles2[i].dataset.character = name || '';
        roles2[i].textContent = `${roles2[i].dataset.role}: ${name || '‚Äî'}`;
        if (name) assigned.add(name);
      });
    }
    if (Array.isArray(s.assigned)) s.assigned.forEach(n => assigned.add(n));
    if (s.currentPlayer) currentPlayer = s.currentPlayer;

    // UI sync
    updateCurrentPlayerUI();
    markAssignedOnCards();
    updateCounter();
  } catch (e) {
    console.warn('restoreTeams failed', e);
  }
}

/* ---------- NATIVE drag & drop for roles (within same team) ---------- */
let _dragSrc = null;

function initSortable() {
  document.querySelectorAll('.roles-list').forEach(list => {
    new Sortable(list, {
      animation: 150,
      ghostClass: 'role-ghost', // classe visuale durante il trascinamento
      onEnd: function () {
        // salva nuovo ordine appena finito il drag
        persistTeams();
        markAssignedOnCards();
        updateCounter();
      }
    });
  });
}
/* ----------------- Normalizzazione ruoli + helper label/handle ----------------- */
function normalizeRoles() {
  document.querySelectorAll('.role').forEach(r => {
    const roleName = r.dataset.role || r.getAttribute('data-role') || '';
    // determina character corrente (preferisce dataset se impostato)
    let currentChar = r.dataset.character ?? '';
    if (!currentChar) {
      const parts = r.textContent.split(':');
      const after = parts.length > 1 ? parts.slice(1).join(':').trim() : '';
      currentChar = (after && after !== '‚Äî') ? after : '';
    }
    // ricrea struttura: handle + label
    r.innerHTML = '';
    const handle = document.createElement('span');
    handle.className = 'drag-handle';
    handle.innerHTML = '‚ò∞';
    r.appendChild(handle);

    const label = document.createElement('span');
    label.className = 'role-label';
    label.textContent = `${roleName}: ${currentChar || '‚Äî'}`;
    r.appendChild(label);

    r.dataset.role = roleName;
    r.dataset.character = currentChar || '';
  });
}

function setRoleCharacter(roleEl, name) {
  roleEl.dataset.character = name || '';
  const label = roleEl.querySelector('.role-label');
  if (label) label.textContent = `${roleEl.dataset.role}: ${name || '‚Äî'}`;
}

function swapRoleCharacters(elA, elB) {
  const a = elA.dataset.character || '';
  const b = elB.dataset.character || '';
  setRoleCharacter(elA, b);
  setRoleCharacter(elB, a);
  persistTeams();
  markAssignedOnCards();
}

/* ----------------- Modal / stato swap ----------------- */
let swapModalEl = null;
const swapState = { open: false, active: false, team: null, picks: [] };

function createSwapModal() {
  if (swapModalEl) return;

  // overlay
  const overlay = document.createElement('div');
  overlay.id = 'swapOverlay';
  document.body.appendChild(overlay);

  swapModalEl = document.createElement('div');
  swapModalEl.id = 'swapModal';
  swapModalEl.innerHTML = `
    <h3>‚öîÔ∏è Fase di Switch ‚öîÔ∏è</h3>
    <p id="swapMsg">Ogni giocatore pu√≤ scambiare due ruoli nella propria squadra.</p>
    <div class="swap-actions">
      <button id="swapBtn1">üè¥‚Äç‚ò†Ô∏è Scambia Team 1</button>
      <button id="swapBtn2">‚ò†Ô∏è Scambia Team 2</button>
      <button id="swapDone">‚úÖ Inizia Arena</button>
      <button id="swapCancel">‚ùå Annulla</button>
    </div>
    <p style="font-size:12px;opacity:.8">Durante lo scambio: clicca due ruoli per scambiarli.<br>
    Puoi ripetere pi√π volte prima di premere "Inizia Arena".</p>
  `;
  document.body.appendChild(swapModalEl);

  // Bottoni
  document.getElementById('swapBtn1').addEventListener('click', () => startSwapForTeam('team1'));
  document.getElementById('swapBtn2').addEventListener('click', () => startSwapForTeam('team2'));
  document.getElementById('swapDone').addEventListener('click', () => {
  closeSwapModal();
  showVsBanner('VS');   // üëà mostra la scritta qui
  // fai partire l'arena dopo un piccolo delay
  setTimeout(() => {
    startArenaAfterVS();
  }, 1200); // 1,2s per dare tempo all‚Äôanimazione "VS"
});
  document.getElementById('swapCancel').addEventListener('click', () => {
    closeSwapModal();
  });

  // Chiudi anche cliccando fuori
  overlay.style.pointerEvents = 'none';
}

function openSwapModal() {
  createSwapModal();
  document.getElementById('swapOverlay').style.display = 'block';
  swapModalEl.classList.add('show');
  swapState.open = true;
}

function closeSwapModal() {
  document.getElementById('swapOverlay').style.display = 'none';
  swapModalEl.classList.remove('show');
  swapState.open = false;
  swapState.active = false;
  swapState.team = null;
  swapState.picks = [];
  document.querySelectorAll('.role').forEach(r => r.classList.remove('selected-for-swap'));
}


function startSwapForTeam(teamId) {
  swapState.active = true;
  swapState.team = teamId;
  swapState.picks = [];
  document.getElementById('swapMsg').textContent =
    `Seleziona due ruoli della squadra ${teamId === 'team1' ? '1' : '2'} da scambiare.`;

  // üëá aggiungi queste due righe per nascondere la schermata
  document.getElementById('swapOverlay').style.display = 'none';
  swapModalEl.classList.remove('show');
}

/* listener delegato per selezione ruoli quando siamo in swap-mode */
document.addEventListener('click', function (e) {
  if (!swapState.active) return;         // non siamo in modalit√† swap
  const role = e.target.closest('.role');
  if (!role) return;
  const team = role.closest('.team');
  if (!team || team.id !== swapState.team) {
    alert('Seleziona ruoli solo nella squadra scelta.');
    return;
  }

  // gestione selezione / deselezione
  if (role.classList.contains('selected-for-swap')) {
    role.classList.remove('selected-for-swap');
    swapState.picks = swapState.picks.filter(r => r !== role);
    return;
  }

  role.classList.add('selected-for-swap');
  swapState.picks.push(role);

if (swapState.picks.length === 2) {
  const [r1, r2] = swapState.picks;
  swapRoleCharacters(r1, r2);

  // aggiorna messaggio e riapri la modal
  openSwapModal();
  document.getElementById('swapMsg').textContent =
    'Scambio effettuato. Puoi scambiare ancora o premere "Inizia Arena".';

  swapState.picks.forEach(r => r.classList.remove('selected-for-swap'));
  swapState.picks = [];
}
});

/* ----------------- Sostituisci checkTeamsFull() con questa versione ----------------- */
function checkTeamsFull() {
  if (teamsAreFull()) {
    // apri modal con opzioni di swap
    openSwapModal();
  }
}


// call this once after DOM load / restoreTeams
// makeRolesDraggable();

function resetTeams() {
  ['team1','team2'].forEach(id => {
    document.querySelectorAll(`#${id} .role`).forEach(r => {
      r.textContent = `${r.dataset.role}: ‚Äî`;
      r.dataset.character = '';
    });
  });
  assigned.clear();
  currentPlayer = 1;
  persistTeams();
  updateCurrentPlayerUI();
  markAssignedOnCards();
  updateCounter();
}

$('resetBtn').addEventListener('click', () => {
  if (confirm('Resetta le squadre?')) resetTeams();
});

// --- Particelle randomiche ---
function spawnParticle() {
  const container = document.getElementById("particleContainer");
  const p = document.createElement("div");
  p.className = "particle";
  p.style.left = Math.random() * 100 + "vw";
  p.style.top = "-10px";
  p.style.width = p.style.height = (Math.random() * 6 + 4) + "px";
  
  container.appendChild(p);
  setTimeout(() => p.remove(), 2000);
}

// --- Fumo randomico ---
function spawnSmoke() {
  const container = document.getElementById("particleContainer");
  const s = document.createElement("div");
  s.className = "smoke";
  s.style.left = Math.random() * 80 + 10 + "vw"; // margini 10-90%
  s.style.top = (50 + Math.random() * 20) + "vh"; // met√† schermo circa
  s.style.transform = `scale(${0.5 + Math.random()})`;
  
  container.appendChild(s);
  setTimeout(() => s.remove(), 3000);
}

// --- Generazione casuale durante arena ---
// --- Generazione rapida durante arena ---
setInterval(() => {
  if (document.getElementById("arenaOverlay").style.display === "flex") {
    // pi√π particelle per volta
    for (let i = 0; i < 3; i++) spawnParticle();
    // pi√π fumo con maggiore probabilit√†
    if (Math.random() < 0.6) spawnSmoke();
  }
}, 200); // intervallo dimezzato (0.2s invece di 0.4s)





  load();
  </script>
 <div id="vsBanner" aria-hidden="true">VS</div>
<!-- A R E N A -->
<div id="arenaOverlay" aria-hidden="true">
  <div id="particleContainer"></div>
    <div id="arenaTop">
    <div id="arenaDuelCounter"></div>
    <div id="arenaScore"></div>
  </div>
  <div id="duelWrapper"></div>
  <div id="arenaBottom">
    <button id="arenaClose" class="arena-btn">Chiudi Arena</button>
  </div>
</div>

  </body>
  </html>
